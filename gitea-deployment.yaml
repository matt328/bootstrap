apiVersion: v1
kind: Namespace
metadata:
  name: tools
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea
  namespace: tools
stringData:
  assertions: ""
  config_environment.sh: "#!/usr/bin/env bash\nset -euo pipefail\n\nfunction env2ini::log()
    {\n  printf \"${1}\\n\"\n}\n\nfunction env2ini::read_config_to_env() {\n  local
    section=\"${1}\"\n  local line=\"${2}\"\n\n  if [[ -z \"${line}\" ]]; then\n    #
    skip empty line\n    return\n  fi\n  \n  # 'xargs echo -n' trims all leading/trailing
    whitespaces and a trailing new line\n  local setting=\"$(awk -F '=' '{print $1}'
    <<< \"${line}\" | xargs echo -n)\"\n\n  if [[ -z \"${setting}\" ]]; then\n    env2ini::log
    '  ! invalid setting'\n    exit 1\n  fi\n\n  local value=''\n  local regex=\"^${setting}(\\s*)=(\\s*)(.*)\"\n
    \ if [[ $line =~ $regex ]]; then\n    value=\"${BASH_REMATCH[3]}\"\n  else\n    env2ini::log
    '  ! invalid setting'\n    exit 1\n  fi\n\n  env2ini::log \"    + '${setting}'\"\n\n
    \ if [[ -z \"${section}\" ]]; then\n    export \"GITEA____${setting^^}=${value}\"
    \                          # '^^' makes the variable content uppercase\n    return\n
    \ fi\n\n  local masked_section=\"${section//./_0X2E_}\"                            #
    '//' instructs to replace all matches\n  masked_section=\"${masked_section//-/_0X2D_}\"\n\n
    \ export \"GITEA__${masked_section^^}__${setting^^}=${value}\"        # '^^' makes
    the variable content uppercase\n}\n\nfunction env2ini::reload_preset_envs() {\n
    \ env2ini::log \"Reloading preset envs...\"\n\n  while read -r line; do\n    if
    [[ -z \"${line}\" ]]; then\n      # skip empty line\n      return\n    fi\n\n
    \   # 'xargs echo -n' trims all leading/trailing whitespaces and a trailing new
    line\n    local setting=\"$(awk -F '=' '{print $1}' <<< \"${line}\" | xargs echo
    -n)\"\n\n    if [[ -z \"${setting}\" ]]; then\n      env2ini::log '  ! invalid
    setting'\n      exit 1\n    fi\n\n    local value=''\n    local regex=\"^${setting}(\\s*)=(\\s*)(.*)\"\n
    \   if [[ $line =~ $regex ]]; then\n      value=\"${BASH_REMATCH[3]}\"\n    else\n
    \     env2ini::log '  ! invalid setting'\n      exit 1\n    fi\n\n    env2ini::log
    \"  + '${setting}'\"\n\n    export \"${setting^^}=${value}\"                           #
    '^^' makes the variable content uppercase\n  done < \"/tmp/existing-envs\"\n\n
    \ rm /tmp/existing-envs\n}\n\n\nfunction env2ini::process_config_file() {\n  local
    config_file=\"${1}\"\n  local section=\"$(basename \"${config_file}\")\"\n\n  if
    [[ $section == '_generals_' ]]; then\n    env2ini::log \"  [ini root]\"\n    section=''\n
    \ else\n    env2ini::log \"  ${section}\"\n  fi\n\n  while read -r line; do\n
    \   env2ini::read_config_to_env \"${section}\" \"${line}\"\n  done < <(awk 1 \"${config_file}\")
    \                            # Helm .toYaml trims the trailing new line which
    breaks line processing; awk 1 ... adds it back while reading\n}\n\nfunction env2ini::load_config_sources()
    {\n  local path=\"${1}\"\n\n  if [[ -d \"${path}\" ]]; then\n    env2ini::log
    \"Processing $(basename \"${path}\")...\"\n\n    while read -d '' configFile;
    do\n      env2ini::process_config_file \"${configFile}\"\n    done < <(find \"${path}\"
    -type l -not -name '..data' -print0)\n\n    env2ini::log \"\\n\"\n  fi\n}\n\nfunction
    env2ini::generate_initial_secrets() {\n  # These environment variables will either
    be\n  #   - overwritten with user defined values,\n  #   - initially used to set
    up Gitea\n  # Anyway, they won't harm existing app.ini files\n\n  export GITEA__SECURITY__INTERNAL_TOKEN=$(gitea
    generate secret INTERNAL_TOKEN)\n  export GITEA__SECURITY__SECRET_KEY=$(gitea
    generate secret SECRET_KEY)\n  export GITEA__OAUTH2__JWT_SECRET=$(gitea generate
    secret JWT_SECRET)\n  export GITEA__SERVER__LFS_JWT_SECRET=$(gitea generate secret
    LFS_JWT_SECRET)\n\n  env2ini::log \"...Initial secrets generated\\n\"\n}\n\n#
    save existing envs prior to script execution. Necessary to keep order of preexisting
    and custom envs\nenv | (grep GITEA || [[ $? == 1 ]]) > /tmp/existing-envs\n\n#
    MUST BE CALLED BEFORE OTHER CONFIGURATION\nenv2ini::generate_initial_secrets\n\nenv2ini::load_config_sources
    '/env-to-ini-mounts/inlines/'\nenv2ini::load_config_sources '/env-to-ini-mounts/additionals/'\n\n#
    load existing envs to override auto generated envs\nenv2ini::reload_preset_envs\n\nenv2ini::log
    \"=== All configuration sources loaded ===\\n\"\n\n# safety to prevent rewrite
    of secret keys if an app.ini already exists\nif [ -f ${GITEA_APP_INI} ]; then\n
    \ env2ini::log 'An app.ini file already exists. To prevent overwriting secret
    keys, these settings are dropped and remain unchanged:'\n  env2ini::log '  - security.INTERNAL_TOKEN'\n
    \ env2ini::log '  - security.SECRET_KEY'\n  env2ini::log '  - oauth2.JWT_SECRET'\n
    \ env2ini::log '  - server.LFS_JWT_SECRET'\n\n  unset GITEA__SECURITY__INTERNAL_TOKEN\n
    \ unset GITEA__SECURITY__SECRET_KEY\n  unset GITEA__OAUTH2__JWT_SECRET\n  unset
    GITEA__SERVER__LFS_JWT_SECRET\nfi\n\nenvironment-to-ini -o $GITEA_APP_INI"
type: Opaque
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea-init
  namespace: tools
stringData:
  configure_gitea.sh: |-
    #!/usr/bin/env bash

    set -euo pipefail

    echo '==== BEGIN GITEA CONFIGURATION ===='

    { # try
      gitea migrate
    } || { # catch
      echo "Gitea migrate might fail due to database connection...This init-container will try again in a few seconds"
      exit 1
    }
    function configure_admin_user() {
      local ACCOUNT_ID=$(gitea admin user list --admin | grep -e "\s\+${GITEA_ADMIN_USERNAME}\s\+" | awk -F " " "{printf \$1}")
      if [[ -z "${ACCOUNT_ID}" ]]; then
        echo "No admin user '${GITEA_ADMIN_USERNAME}' found. Creating now..."
        gitea admin user create --admin --username "${GITEA_ADMIN_USERNAME}" --password "${GITEA_ADMIN_PASSWORD}" --email "gitea@local.domain" --must-change-password=false
        echo '...created.'
      else
        echo "Admin account '${GITEA_ADMIN_USERNAME}' already exist. Running update to sync password..."
        gitea admin user change-password --username "${GITEA_ADMIN_USERNAME}" --password "${GITEA_ADMIN_PASSWORD}"
        echo '...password sync done.'
      fi
    }

    configure_admin_user

    function configure_ldap() {
        echo 'no ldap configuration... skipping.'
    }

    configure_ldap

    function configure_oauth() {
        echo 'no oauth configuration... skipping.'
    }

    configure_oauth

    echo '==== END GITEA CONFIGURATION ===='
  configure_gpg_environment.sh: |-
    #!/usr/bin/env bash
    set -eu

    gpg --batch --import /raw/private.asc
  init_directory_structure.sh: |-
    #!/usr/bin/env bash

    set -euo pipefail

    set -x
    mkdir -p /data/git/.ssh
    chmod -R 700 /data/git/.ssh
    [ ! -d /data/gitea/conf ] && mkdir -p /data/gitea/conf

    # prepare temp directory structure
    mkdir -p "${GITEA_TEMP}"
    chmod ug+rwx "${GITEA_TEMP}"
type: Opaque
---
apiVersion: v1
kind: Secret
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea-inline-config
  namespace: tools
stringData:
  _generals_: ""
  cache: ADAPTER=memory
  database: |-
    DB_TYPE=postgres
    HOST=gitea-postgresql
    NAME=gitea
    PASSWD=gitea
    USER=gitea
  indexer: ISSUE_INDEXER_TYPE=db
  metrics: ENABLED=false
  queue: TYPE=level
  repository: ROOT=/data/git/gitea-repositories
  security: INSTALL_LOCK=true
  server: |-
    APP_DATA_PATH=/data
    DOMAIN=gitea.home
    ENABLE_PPROF=false
    HTTP_PORT=3000
    PROTOCOL=http
    ROOT_URL=http://gitea.home
    SSH_DOMAIN=gitea.home
    SSH_LISTEN_PORT=2222
    SSH_PORT=22
    START_SSH_SERVER=true
  session: |-
    PROVIDER=memory
    PROVIDER_CONFIG=
type: Opaque
---
apiVersion: v1
data:
  password: Z2l0ZWE=
  postgres-password: Z2l0ZWE=
kind: Secret
metadata:
  labels:
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-12.6.6
  name: gitea-postgresql
  namespace: tools
type: Opaque
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: gitea
  name: gitea
  namespace: tools
spec:
  ports:
  - name: gitea-http
    port: 80
    protocol: TCP
    targetPort: 3000
  - name: gitea-ssh
    port: 22
    protocol: TCP
    targetPort: 2222
  selector:
    app: gitea
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea-http
  namespace: tools
spec:
  clusterIP: None
  ports:
  - name: http
    port: 3000
    targetPort: null
  selector:
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/name: gitea
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: primary
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-12.6.6
  name: gitea-postgresql
  namespace: tools
spec:
  ports:
  - name: tcp-postgresql
    nodePort: null
    port: 5432
    targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/component: primary
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/name: postgresql
  sessionAffinity: None
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: primary
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-12.6.6
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  name: gitea-postgresql-hl
  namespace: tools
spec:
  clusterIP: None
  ports:
  - name: tcp-postgresql
    port: 5432
    targetPort: tcp-postgresql
  publishNotReadyAddresses: true
  selector:
    app.kubernetes.io/component: primary
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/name: postgresql
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea-ssh
  namespace: tools
spec:
  clusterIP: None
  ports:
  - name: ssh
    port: 22
    protocol: TCP
    targetPort: 2222
  selector:
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/name: gitea
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea
  namespace: tools
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/instance: gitea
      app.kubernetes.io/name: gitea
  strategy:
    rollingUpdate:
      maxSurge: 100%
      maxUnavailable: 0
    type: RollingUpdate
  template:
    metadata:
      annotations:
        checksum/config: 429a5d76450a9b5a6c51225d62508a4678a66ed1502afb4b84c9d9ba4f0c5d7a
      labels:
        app: gitea
        app.kubernetes.io/instance: gitea
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: gitea
        app.kubernetes.io/version: 1.20-nightly
        helm.sh/chart: gitea-9.0.3
        version: 1.20-nightly
    spec:
      containers:
      - env:
        - name: SSH_LISTEN_PORT
          value: "2222"
        - name: SSH_PORT
          value: "22"
        - name: GITEA_APP_INI
          value: /data/gitea/conf/app.ini
        - name: GITEA_CUSTOM
          value: /data/gitea
        - name: GITEA_WORK_DIR
          value: /data
        - name: GITEA_TEMP
          value: /tmp/gitea
        - name: TMPDIR
          value: /tmp/gitea
        - name: HOME
          value: /data/gitea/git
        image: gitea/gitea:1.20-nightly-rootless
        imagePullPolicy: Always
        livenessProbe:
          failureThreshold: 10
          initialDelaySeconds: 200
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: http
          timeoutSeconds: 1
        name: gitea
        ports:
        - containerPort: 2222
          name: ssh
        - containerPort: 3000
          name: http
        readinessProbe:
          failureThreshold: 3
          initialDelaySeconds: 5
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: http
          timeoutSeconds: 1
        resources: {}
        securityContext: {}
        volumeMounts:
        - mountPath: /tmp
          name: temp
        - mountPath: /data
          name: data
      initContainers:
      - command:
        - /usr/sbin/init_directory_structure.sh
        env:
        - name: GITEA_APP_INI
          value: /data/gitea/conf/app.ini
        - name: GITEA_CUSTOM
          value: /data/gitea
        - name: GITEA_WORK_DIR
          value: /data
        - name: GITEA_TEMP
          value: /tmp/gitea
        image: gitea/gitea:1.20-nightly-rootless
        imagePullPolicy: Always
        name: init-directories
        resources:
          limits: {}
          requests:
            cpu: 100m
            memory: 128Mi
        securityContext: {}
        volumeMounts:
        - mountPath: /usr/sbin
          name: init
        - mountPath: /tmp
          name: temp
        - mountPath: /data
          name: data
      - command:
        - /usr/sbin/config_environment.sh
        env:
        - name: GITEA_APP_INI
          value: /data/gitea/conf/app.ini
        - name: GITEA_CUSTOM
          value: /data/gitea
        - name: GITEA_WORK_DIR
          value: /data
        - name: GITEA_TEMP
          value: /tmp/gitea
        image: gitea/gitea:1.20-nightly-rootless
        imagePullPolicy: Always
        name: init-app-ini
        resources:
          limits: {}
          requests:
            cpu: 100m
            memory: 128Mi
        securityContext: {}
        volumeMounts:
        - mountPath: /usr/sbin
          name: config
        - mountPath: /tmp
          name: temp
        - mountPath: /data
          name: data
        - mountPath: /env-to-ini-mounts/inlines/
          name: inline-config-sources
      - command:
        - /usr/sbin/configure_gitea.sh
        env:
        - name: GITEA_APP_INI
          value: /data/gitea/conf/app.ini
        - name: GITEA_CUSTOM
          value: /data/gitea
        - name: GITEA_WORK_DIR
          value: /data
        - name: GITEA_TEMP
          value: /tmp/gitea
        - name: HOME
          value: /data/gitea/git
        - name: GITEA_ADMIN_USERNAME
          value: gitea_admin
        - name: GITEA_ADMIN_PASSWORD
          value: r8sA8CPHD9!bt6d
        image: gitea/gitea:1.20-nightly-rootless
        imagePullPolicy: Always
        name: configure-gitea
        resources:
          limits: {}
          requests:
            cpu: 100m
            memory: 128Mi
        securityContext:
          runAsUser: 1000
        volumeMounts:
        - mountPath: /usr/sbin
          name: init
        - mountPath: /tmp
          name: temp
        - mountPath: /data
          name: data
      securityContext:
        fsGroup: 1000
      terminationGracePeriodSeconds: 60
      volumes:
      - name: init
        secret:
          defaultMode: 110
          secretName: gitea-init
      - name: config
        secret:
          defaultMode: 110
          secretName: gitea
      - name: inline-config-sources
        secret:
          secretName: gitea-inline-config
      - emptyDir: {}
        name: temp
      - emptyDir: {}
        name: data
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/component: primary
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: postgresql
    helm.sh/chart: postgresql-12.6.6
  name: gitea-postgresql
  namespace: tools
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/component: primary
      app.kubernetes.io/instance: gitea
      app.kubernetes.io/name: postgresql
  serviceName: gitea-postgresql-hl
  template:
    metadata:
      labels:
        app.kubernetes.io/component: primary
        app.kubernetes.io/instance: gitea
        app.kubernetes.io/managed-by: Helm
        app.kubernetes.io/name: postgresql
        helm.sh/chart: postgresql-12.6.6
      name: gitea-postgresql
    spec:
      affinity:
        nodeAffinity: null
        podAffinity: null
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchLabels:
                  app.kubernetes.io/component: primary
                  app.kubernetes.io/instance: gitea
                  app.kubernetes.io/name: postgresql
              topologyKey: kubernetes.io/hostname
            weight: 1
      containers:
      - env:
        - name: BITNAMI_DEBUG
          value: "false"
        - name: POSTGRESQL_PORT_NUMBER
          value: "5432"
        - name: POSTGRESQL_VOLUME_DIR
          value: /bitnami/postgresql
        - name: PGDATA
          value: /bitnami/postgresql/data
        - name: POSTGRES_USER
          value: gitea
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: gitea-postgresql
        - name: POSTGRES_POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              key: postgres-password
              name: gitea-postgresql
        - name: POSTGRES_DATABASE
          value: gitea
        - name: POSTGRESQL_ENABLE_LDAP
          value: "no"
        - name: POSTGRESQL_ENABLE_TLS
          value: "no"
        - name: POSTGRESQL_LOG_HOSTNAME
          value: "false"
        - name: POSTGRESQL_LOG_CONNECTIONS
          value: "false"
        - name: POSTGRESQL_LOG_DISCONNECTIONS
          value: "false"
        - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
          value: "off"
        - name: POSTGRESQL_CLIENT_MIN_MESSAGES
          value: error
        - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
          value: pgaudit
        image: docker.io/bitnami/postgresql:15.3.0-debian-11-r24
        imagePullPolicy: IfNotPresent
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - exec pg_isready -U "gitea" -d "dbname=gitea" -h 127.0.0.1 -p 5432
          failureThreshold: 6
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        name: postgresql
        ports:
        - containerPort: 5432
          name: tcp-postgresql
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - -e
            - |
              exec pg_isready -U "gitea" -d "dbname=gitea" -h 127.0.0.1 -p 5432
              [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]
          failureThreshold: 6
          initialDelaySeconds: 5
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 5
        resources:
          limits: {}
          requests:
            cpu: 250m
            memory: 256Mi
        securityContext:
          runAsUser: 1001
        volumeMounts:
        - mountPath: /dev/shm
          name: dshm
        - mountPath: /bitnami/postgresql
          name: data
      hostIPC: false
      hostNetwork: false
      securityContext:
        fsGroup: 1001
      serviceAccountName: default
      volumes:
      - emptyDir:
          medium: Memory
        name: dshm
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  volumeClaimTemplates:
  - apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 10Gi
---
apiVersion: v1
kind: Pod
metadata:
  annotations:
    helm.sh/hook: test-success
  labels:
    app: gitea
    app.kubernetes.io/instance: gitea
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: gitea
    app.kubernetes.io/version: 1.20-nightly
    helm.sh/chart: gitea-9.0.3
    version: 1.20-nightly
  name: gitea-test-connection
  namespace: tools
spec:
  containers:
  - args:
    - gitea-http:3000
    command:
    - wget
    image: busybox:latest
    name: wget
  restartPolicy: Never
